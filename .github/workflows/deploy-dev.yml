name: Développement

# Ce workflow se déclenche manuellement uniquement
on:
  # Déclenche le workflow manuellement depuis l'interface GitHub
  workflow_dispatch:
    inputs:
      reason:
        description: "Raison du déploiement"
        required: false
        default: "Déploiement manuel"

# Variables d'environnement utilisées dans le workflow
# Ces variables sont partagées par tous les jobs du workflow
env:
  REGISTRY: ghcr.io # GitHub Container Registry - où sont stockées nos images Docker
  IMAGE_NAME: ${{ github.repository }} # Nom du repository GitHub (ex: elyamajeorg/elyamajeplay-backend)

# ================================================================================================
# JOBS DE CONSTRUCTION (BUILD) - Ces jobs créent les images Docker
# ================================================================================================

jobs:
  # Job 1: Construction de l'image Devoups Agent
  # Ce job créé une image Docker contenant notre application Node.js
  build-devoups-agent:
    # Condition : Ce job s'exécute lors d'un déclenchement manuel
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      pull-requests: read

    steps:
      # Étape 1: Télécharger le code source
      - name: Checkout repository
        uses: actions/checkout@v4

      # Étape 2: Supprimer l'ancien fichier .env s'il existe
      # Le fichier .env contient les variables d'environnement de l'application
      - name: Clean old .env file
        run: rm -f .env

      # Étape 3: Créer le fichier .env avec toutes les variables d'environnement
      # Ces variables configurent l'application (base de données, services externes, etc.)
      - name: Create .env file
        run: |
          set -euo pipefail
          cat <<'EOF' > .env
          AGENT_TOKEN="kCYDJLUfDY1g8i1mVmOoxy"
          AGENT_HOSTNAME="vps-dev-global"
          EOF

      # Étape 4: Afficher le contenu du fichier .env pour débugger
      # Cela nous permet de vérifier que toutes les variables sont bien définies
      - name: Debug .env
        run: |
          echo "------ Contenu de .env ------"
          cat .env
          echo "----------------------------------------"

      # Étape 5: Se connecter au registre Docker
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.PAT_GITHUB_TOKEN }}

      # Étape 6: Rendre le script de construction Devoups Agent exécutable
      - name: Make Devoups Agent script executable
        run: chmod +x build-agent-image.sh

      # Étape 7: Construire et publier l'image Devoups Agent
      - name: Build Devoups Agent image
        run: |
          # Réponses automatiques au script :
          # - 'n' : Ne pas exécuter l'image localement
          # - 'y' : Publier l'image sur GitHub Container Registry
          echo -e "n\ny" | ./build-agent-image.sh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ================================================================================================
  # JOBS DE DÉPLOIEMENT (DEPLOY) - Ces jobs déploient les conteneurs sur le serveur
  # ===============================================================================================

  # Job 4: Déploiement du conteneur Devoups Agent
  # Ce job prend l'image Devoups Agent créée et la déploie sur le serveur develop
  deploy-devoups-agent:
    # Condition : Ce job s'exécute lors d'un déclenchement manuel
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    needs: [build-devoups-agent] # Ce job attend que build-devoups-agent soit terminé

    steps:
      # Étape unique : Se connecter au serveur et déployer le Devoups Agent
      - name: "Déploiement Devoups Agent sur le serveur de develop"
        # Cette étape s'exécute si le job build-devoups a réussi
        if: needs.build-devoups-agent.result == 'success'
        shell: bash
        run: |
          # Arrêter le script en cas d'erreur
          set -e

          # Créer le dossier SSH et configurer la clé privée
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Se connecter au serveur develop via SSH et exécuter les commandes de déploiement
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key -p 53796 ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST_DEV }} << 'EOF'
            echo "Authentification à GitHub Container Registry..."
            # Se connecter au registre Docker de GitHub sur le serveur
            echo "${{ secrets.PAT_GITHUB_TOKEN }}" |  docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            echo "Arrêt et suppression du conteneur Devoups Agent existant s'il existe..."
            # Arrêter le conteneur Devoups Agent s'il tourne déjà
             docker stop devoups-agent || true
            # Supprimer le conteneur Devoups Agent s'il existe
             docker rm devoups-agent || true
            # Supprimer l'ancienne image Devoups Agent pour économiser l'espace
             echo "Suppression de l'image Devoups Agent locale existante (si présente)..."
             ATTEMPTS=0
             MAX_ATTEMPTS=3
             IMAGE_NAME="ghcr.io/elyamajeorg/devoups-agent:latest"

             while docker images $IMAGE_NAME --format '{{.Repository}}:{{.Tag}}' | grep -q "$IMAGE_NAME"; do
               docker rmi $IMAGE_NAME || true
               ATTEMPTS=$((ATTEMPTS + 1))
               sleep 2
               if [ $ATTEMPTS -ge $MAX_ATTEMPTS ]; then
                 echo "L'image $IMAGE_NAME n'a pas pu être supprimée après $MAX_ATTEMPTS tentatives. Arrêt du déploiement."
                 exit 1
               fi
               echo "Nouvelle tentative de suppression de l'image ($ATTEMPTS/$MAX_ATTEMPTS)..."
             done
             echo "Image $IMAGE_NAME supprimée ou absente, poursuite du déploiement."
            
            echo "Récupération de l'image Devoups Agent..."
            # Télécharger la dernière version de l'image Devoups Agent
            docker pull ghcr.io/elyamajeorg/devoups-agent:latest
            
            echo "Démarrage du conteneur Devoups Agent..."
            # Démarrer le conteneur sur le réseau bridge (par défaut) puis le connecter au réseau personnalisé
            # docker run -d --name devoups-agent  -p 7081:7081 ghcr.io/elyamajeorg/devoups-agent:latest
            docker run -d \
              --name devoups-agent \
              --restart unless-stopped \
              --privileged \
              -v /var/run/docker.sock:/var/run/docker.sock \
              -p 7081:7081 \
              ghcr.io/elyamajeorg/devoups-agent:latest

            echo "Vérification du statut du conteneur Devoups Agent..."
            # Vérifier que le conteneur Devoups Agent fonctionne correctement
             docker ps | grep devoups-agent
          EOF
          echo "Déploiement Devoups Agent terminé"

      # Étape finale : Message de succès
      - name: "Fin du workflow de déploiement Devoups Agent"
        run: echo "Déploiement Devoups Agent terminé avec succès."
        if: success()

  # Job 5: Vérification du conteneur Devoups Agent
  verify-devoups-agent-container:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    needs: [deploy-devoups-agent]
    steps:
      - name: "Vérification du conteneur Docker sur le serveur de develop (Devoups Agent)"
        shell: bash
        run: |
          set -e
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/deploy_key -p 53796 ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST_DEV }} << 'EOF'
            echo "Vérification HTTP /healthcheck..."
            HEALTH_RESPONSE=$(curl --silent --fail http://127.0.0.1:7081/healthcheck || true)
            echo "Réponse healthcheck:"
            echo "$HEALTH_RESPONSE"

            if [ -z "$HEALTH_RESPONSE" ]; then
              echo "Aucune réponse reçue du point de contrôle de santé."
              exit 1
            fi

            if ! echo "$HEALTH_RESPONSE" | jq -e '.status == "ok"' >/dev/null 2>&1; then
              echo "Statut healthcheck invalide (attendu status=ok)."
            exit 1
            fi

            echo "Vérification healthcheck réussie."
          EOF
          echo "Vérification du conteneur Devoups Agent terminée"
        continue-on-error: false
